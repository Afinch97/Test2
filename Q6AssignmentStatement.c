#include <stdio.h>
/* Assignment Statement
Parses strings in the language generated by the rule:
 <expr> -> ID = <term> {(+ | -) <term>}
 <term> -> <factor> {(* | /) <factor>}
 <factor> -> ID | C_INT_LIT | "(" <expr> ")"
*/

void expr(void) {
	if (nextToken != ID) {
		error();
	}
	else {
		if (nextToken != ASSIGN) {
			error();
		}
		else {
			term();
			while (nextToken == ADD_OP || nextToken == SUB_OP) {
				lex();
				term();
			}
			//printf("Exit <expr>\n");
		}
	}
}

void term(void) {
	//printf("Enter <term>\n");
	/* Parse the first factor */
	factor();
	/* As long as the next token is * or /, get the
	 next token and parse the next factor */
	while (nextToken == MULT_OP || nextToken == DIV_OP) {
		lex();
		factor();
	}
	//printf("Exit <term>\n");
}

void factor(void) {
	//printf("Enter <factor>\n");
	/* Determine which RHS */
	if (nextToken == IDENT || nextToken == INT_LIT) {
		/* Get the next token */
		lex();
	}
	/* If the RHS is ( <expr> ), call lex to pass over the
	 left parenthesis, call expr, and check for the right
	 parenthesis */
	else {
		if (nextToken == LEFT_PAREN) {
			lex();
			expr();
			if (nextToken == RIGHT_PAREN)
				lex();
			else
				error();
		}
		/* It was not an id, an integer literal, or a left
		 parenthesis */
		else
			error();
	}
	//printf("Exit <factor>\n");
}